<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>WebRTC + WebSocket señalización automática</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    text-align: center;
    margin: 0;
    padding: 1em;
  }
  video {
    max-width: 90vw;
    max-height: 70vh;
    background: black;
    border: 2px solid #44ff44;
  }
  button {
    font-size: 1.2em;
    margin: 0.5em;
    padding: 0.5em 1em;
    background: #44ff44;
    color: #111;
    border: none;
    border-radius: 5px;
    cursor: pointer;
  }
  #status {
    margin-top: 1em;
    font-family: monospace;
    color: #4aff4a;
  }
</style>
</head>
<body>
<h1>WebRTC + WebSocket señalización automática</h1>
<video id="video" autoplay playsinline></video><br/>
<button id="startBtn">Iniciar transmisión</button>

<div id="status">Estado: desconectado</div>

<script>
(async () => {
  const video = document.getElementById('video');
  const startBtn = document.getElementById('startBtn');
  const status = document.getElementById('status');

  const configuration = {
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  };

  let pc;
  let localStream;
  let ws;

  function logStatus(text) {
    status.textContent = 'Estado: ' + text;
  }

  function createPeerConnection() {
    pc = new RTCPeerConnection(configuration);

    pc.onicecandidate = event => {
      if (event.candidate) return;
      const localDesc = JSON.stringify(pc.localDescription);
      ws.send(localDesc);
      logStatus('Enviando señal SDP');
    };

    pc.ontrack = event => {
      video.srcObject = event.streams[0];
      logStatus('Recibiendo video');
    };
  }

  function setupWebSocket() {
    // Cambiá la IP y puerto por la IP pública o local accesible de tu PC
    ws = new WebSocket('ws://123.45.67.89:8080');

    ws.onopen = () => {
      logStatus('WebSocket conectado');
    };

    ws.onmessage = async (event) => {
      const msg = JSON.parse(event.data);
      if (!pc) createPeerConnection();

      if (msg.type === 'offer') {
        await pc.setRemoteDescription(new RTCSessionDescription(msg));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        ws.send(JSON.stringify(pc.localDescription));
        logStatus('Respuesta enviada');
      } else if (msg.type === 'answer') {
        await pc.setRemoteDescription(new RTCSessionDescription(msg));
        logStatus('Conexión establecida');
      } else if (msg.candidate) {
        try {
          await pc.addIceCandidate(msg);
          logStatus('Candidato ICE agregado');
        } catch (e) {
          console.error('Error agregando ICE candidate:', e);
        }
      }
    };

    ws.onerror = (e) => {
      console.error('WebSocket error:', e);
      logStatus('Error WebSocket');
    };

    ws.onclose = () => {
      logStatus('WebSocket desconectado');
    };
  }

  startBtn.onclick = async () => {
    startBtn.disabled = true;
    setupWebSocket();

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      video.srcObject = localStream;

      createPeerConnection();
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      ws.send(JSON.stringify(pc.localDescription));
      logStatus('Oferta enviada');
    } catch (e) {
      alert('Error accediendo a cámara/micrófono o creando conexión:\n' + e);
      startBtn.disabled = false;
    }
  };
})();
</script>
</body>
</html>
